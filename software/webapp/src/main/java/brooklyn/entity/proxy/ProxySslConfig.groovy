package brooklyn.entity.proxy;

import com.google.common.base.Objects;

public class ProxySslConfig implements Serializable {

    /** 
     * url's for the SSL certificates required at the server
     * <p>
     * nginx settings:
     *     ssl                  on;
     *     ssl_certificate      www.example.com.crt;
     *     ssl_certificate_key  www.example.com.key;
     *  <p>
     *  okay (in nginx) for key to be null if certificate contains both as per setup at
     *  http://nginx.org/en/docs/http/configuring_https_servers.html
     *  <p>
     *  proxy object can be set on nginx instance to apply site-wide,
     *  and to put multiple servers in the certificate file
     *  <p>
     *  the brooklyn entity will install the certificate/key(s) on the server.
     *  (however it will not currently merge multiple certificates.
     *  if conflicting certificates are attempted to be installed nginx will complain.) 
     */
    String certificate, key;

    /** whether the downstream server (if mapping) also expects https; default false */
    boolean targetIsSsl = false;

    /** whether to reuse SSL validation in the server (performance).
     * corresponds to nginx setting: proxy_ssl_session_reuse on|off */
    boolean reuseSessions = false;

    
    // autogenerated hash code and equals; nothing special required
    
    @Override
    public int hashCode() {
		return Objects.hashCode(certificate, key, reuseSessions, targetIsSsl);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        ProxySslConfig other = (ProxySslConfig) obj;
		
		return Objects.equal(certificate, other.certificate) &&
				Objects.equal(key, other.key) &&
				Objects.equal(reuseSessions, other.reuseSessions) &&
				Objects.equal(targetIsSsl, other.targetIsSsl);
    }
}
